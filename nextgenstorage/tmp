package httptest;

import httptest.HttpClientHelper.METHOD;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import model.ContentSummary;
import model.FileChecksum;
import model.FileStatus;
import model.FileStatuses;

import org.apache.http.HttpEntity;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.entity.InputStreamEntity;

import com.google.gson.Gson;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;

public class HdfsAccess {
	private HdfsHttpClientHelper hdfsHttpClientHelper;
	
	public HdfsAccess(HdfsHttpAddress hdfsHttpAddress) {
		this.hdfsHttpClientHelper = new HdfsHttpClientHelper(hdfsHttpAddress);
	}
	
	public HdfsAccess(String host, String port, String username) {
		this.hdfsHttpClientHelper = new HdfsHttpClientHelper(new HdfsHttpAddress(host, port, username));
	}
	
	public HdfsAccess(String protocol, String host, String port, String username) {
		this.hdfsHttpClientHelper = new HdfsHttpClientHelper(new HdfsHttpAddress(protocol, host, port, username));
	}
	
	private abstract class OPERATIONS {
		public static final String CREATE = "CREATE";
		public static final String APPEND = "APPEND";
		public static final String OPEN   = "OPEN";
		public static final String MKDIRS = "MKDIRS";
		public static final String RENAME = "RENAME";
		public static final String GETFILESTATUS = "GETFILESTATUS";
		public static final String LISTSTATUS = "LISTSTATUS";
		public static final String GETCONTENTSUMMARY = "GETCONTENTSUMMARY";
		public static final String GETFILECHECKSUM = "GETFILECHECKSUM";
		public static final String GETHOMEDIRECTORY = "GETHOMEDIRECTORY";
		public static final String SETPERMISSION = "SETPERMISSION";
		public static final String SETOWNER = "SETOWNER";
		public static final String SETREPLICATION = "SETREPLICATION";
		public static final String GETDELEGATIONTOKEN = "GETDELEGATIONTOKEN";
		public static final String RENEWDELEGATIONTOKEN = "RENEWDELEGATIONTOKEN";
		public static final String CANCELDELEGATIONTOKEN = "CANCELDELEGATIONTOKEN";
		public static final String SETTIMES = "SETTIMES";
		public static final String DELETE = "DELETE";
	}
	
	private abstract class STATUS {
		public static final int CREATED = 201;
		public static final int OK = 200;
	}
	
	private abstract class LITERAL {
		public static final String TRUE = "true";
		public static final String FILESTATUS = "FileStatus";
		public static final String FILESTATUSES = "FileStatuses";
		public static final String CONTENTSUMMARY = "ContentSummary";
		public static final String FILECHECKSUM = "FileChecksum";
		public static final String HOMEDIR = "/";
		public static final String LOCATION = "Location";
		
		private abstract class ERROR {
			public static final String ERROR01 = "Local absolute file path could not be a directory.";
		}
	}
	
	
	public abstract class OPTIONS {
		public static final String DESTINATION = "destination";
		public static final String PERMISSION = "permission";
		public static final String OWNER = "owner";
		public static final String GROUP = "group";
		public static final String REPLICATION = "replication";
		public static final String RENEWER = "renewer";
		public static final String TOKEN = "token";
		public static final String MODIFICATIONTIME = "modificationtime";
		public static final String ACCESSTIME = "accesstime";
		public static final String RECURSIVE = "recursive";
	}
	
	/**
	 * [PUT] Create and Write to a File.
	 * @param localPath
	 * @param remotePath
	 * @param options
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 * @throws IllegalArgumentException
	 */
	public boolean upload(String localPath, String remotePath, Map<String, String> options)
			throws ClientProtocolException, IOException, IllegalArgumentException {
		return uploadFile(OPERATIONS.CREATE, localPath, remotePath, METHOD.PUT, options) == STATUS.CREATED;
	}
	
	/**
	 * [POST] Append to a File.
	 * @param localPath
	 * @param remotePath
	 * @param options
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean append(String localPath, String remotePath, Map<String, String> options) 
			throws ClientProtocolException, IOException {
		return uploadFile(OPERATIONS.APPEND, localPath, remotePath, METHOD.POST, options) == STATUS.OK;
	}
	
	/**
	 * [GET] Open and Read a File.
	 * @param remotePath
	 * @param options
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public String open(String remotePath, Map<String, String> options) 
			throws UnsupportedOperationException, IOException {
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.OPEN, options)
				.getHttpResultContent(METHOD.GET);
	}
	
	/**
	 * [PUT] Make a Directory.
	 * @param remotePath
	 * @param options
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean mkdir(String remotePath, Map<String, String> options) 
			throws ClientProtocolException, IOException {
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.MKDIRS, options)
				.getHttpResultContent(METHOD.PUT)
				.contains(LITERAL.TRUE);
	}
	
	/**
	 * [PUT] Rename a File/Directory.
	 * @param remotePath
	 * @param destination
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean rename(String remotePath, String destination) 
			throws ClientProtocolException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.DESTINATION, destination);
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.RENAME, options)
				.getHttpResultContent(METHOD.PUT)
				.contains(LITERAL.TRUE);
	}
	
	/**
	 * Delete a File.
	 * @param remotePath
	 * @param options
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public boolean removeFile(String remotePath) 
			throws UnsupportedOperationException, IOException {
		return remove(remotePath, false);
	}
	
	/**
	 * Delete a Directory
	 * @param remotePath
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public boolean removeDirectory(String remotePath) 
			throws UnsupportedOperationException, IOException {
		return remove(remotePath, true);
	}
	
	/**
	 * Get the status of a File/Directory and the client receives a response with a FileStatus JSON object.
	 * @param remotePath
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public FileStatus getStatus(String remotePath) 
			throws UnsupportedOperationException, IOException {
		String jsonResult = hdfsHttpClientHelper
							 .createHdfsURL(remotePath, OPERATIONS.GETFILESTATUS, null)
				 			 .getHttpResultContent(METHOD.GET);
		
		if(jsonResult.contains(LITERAL.FILESTATUS)) {
			String fileStatusJsonStr = new JsonParser().parse(jsonResult)
													   .getAsJsonObject()
													   .get(LITERAL.FILESTATUS)
													   .toString();
			
			return new Gson().fromJson(fileStatusJsonStr, FileStatus.class);
		}
		return null;
	}
	
	/**
	 * List a Directory and the client receives a response with a FileStatuses JSON object.
	 * @param remotePath
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public FileStatuses listDirectory(String remotePath) 
			throws UnsupportedOperationException, IOException {
		String jsonResult = hdfsHttpClientHelper
							 .createHdfsURL(remotePath, OPERATIONS.LISTSTATUS, null)
							 .getHttpResultContent(METHOD.GET);
		
		if(jsonResult.contains(LITERAL.FILESTATUSES)) {
			String fileStatusesJsonStr = new JsonParser().parse(jsonResult)
											.getAsJsonObject()
											.get(LITERAL.FILESTATUSES)
											.getAsJsonObject()
											.get(LITERAL.FILESTATUS)
											.toString();
			
			List<FileStatus> fileStatusList = 
					new Gson().fromJson(fileStatusesJsonStr, new TypeToken<List<FileStatus>>() {}.getType());
			return new FileStatuses(fileStatusList);
		}
		return null;
	}
	
	/**
	 * Get Content Summary of a Directory and the client receives a response with a ContentSummary JSON object
	 * @param remotePath
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public ContentSummary getDirectoryContentSummary(String remotePath) 
			throws UnsupportedOperationException, IOException {
		String jsonResult = hdfsHttpClientHelper
							 .createHdfsURL(remotePath, OPERATIONS.GETCONTENTSUMMARY, null)
							 .getHttpResultContent(METHOD.GET);
		
		if(jsonResult.contains(LITERAL.CONTENTSUMMARY)) {
			String contentSummaryJsonStr = new JsonParser().parse(jsonResult)
														   .getAsJsonObject()
														   .get(LITERAL.CONTENTSUMMARY)
														   .toString();
			
			return new Gson().fromJson(contentSummaryJsonStr, ContentSummary.class);
		}
		return null;
	}
	
	/**
	 * Get File Checksum and the client follows the redirect to the datanode and receives a FileChecksum JSON object
	 * @param remotePath
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public FileChecksum getFileChecksum(String remotePath) 
			throws UnsupportedOperationException, IOException {
		String jsonResult = hdfsHttpClientHelper
							 .createHdfsURL(remotePath, OPERATIONS.GETFILECHECKSUM, null)
							 .getHttpResultContent(METHOD.GET);
		
		if(jsonResult.contains(LITERAL.FILECHECKSUM)) {
			String fileChecksumJsonStr = new JsonParser().parse(jsonResult)
														 .getAsJsonObject()
														 .get(LITERAL.FILECHECKSUM)
														 .toString();
			
			return new Gson().fromJson(fileChecksumJsonStr, FileChecksum.class);
		}
		return null;
	}
	
	/**
	 * Get Home Directory.
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public String getHomeDirectory() 
			throws UnsupportedOperationException, IOException {
		return hdfsHttpClientHelper
				.createHdfsURL(LITERAL.HOMEDIR, OPERATIONS.GETHOMEDIRECTORY, null)
				.getHttpResultContent(METHOD.GET);
	}
	
	/**
	 * Set Permission.
	 * @param remotePath
	 * @param permission
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean setPermission(String remotePath, int permission) 
			throws ClientProtocolException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.PERMISSION, String.valueOf(permission));
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.SETPERMISSION, options)
				.getHttpResultStatusCode(METHOD.PUT) == STATUS.OK;
	}
	
	/**
	 * Set Owner.
	 * @param remotePath
	 * @param owner
	 * @param group
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean setOwner(String remotePath, String owner, String group) 
			throws ClientProtocolException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.OWNER, owner);
		options.put(OPTIONS.GROUP, group);
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.SETOWNER, options)
				.getHttpResultStatusCode(METHOD.PUT) == STATUS.OK;
	}
	
	/**
	 * Set Replication Factor.
	 * @param remotePath
	 * @param replication
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean setReplicationFactor(String remotePath, short replication)
			throws ClientProtocolException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.REPLICATION, String.valueOf(replication));
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.SETREPLICATION, options)
				.getHttpResultStatusCode(METHOD.PUT) == STATUS.OK;
	}
	
	/**
	 * Set AccessTime.
	 * @param remotePath
	 * @param accesstime
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean setAccessTime(String remotePath, String accesstime) 
			throws ClientProtocolException, IOException {
		return setTimes(remotePath, null, accesstime);
	}
	
	/**
	 * Set ModificationTime.
	 * @param remotePath
	 * @param modificationtime
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean setModificationTime(String remotePath, String modificationtime) 
			throws ClientProtocolException, IOException {
		return setTimes(remotePath, modificationtime, null);
	}
	
	/**
	 * Get Delegation Token.
	 * @param remotePath
	 * @param renewer
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public String getDelegationToken(String renewer) 
			throws UnsupportedOperationException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.RENEWER, renewer);
		return hdfsHttpClientHelper
				.createHdfsURL(LITERAL.HOMEDIR, OPERATIONS.GETDELEGATIONTOKEN, options)
				.getHttpResultContent(METHOD.GET);
	}
	
	/**
	 * Renew Delegation Token.
	 * @param remotePath
	 * @param token
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public String renewDelegationToken(String token) 
			throws UnsupportedOperationException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.TOKEN, token);
		return hdfsHttpClientHelper
				.createHdfsURL(LITERAL.HOMEDIR, OPERATIONS.RENEWDELEGATIONTOKEN, options)
				.getHttpResultContent(METHOD.PUT);
	}
	
	/**
	 * Cancel Delegation Token.
	 * @param token
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public boolean cancelDelegationToken(String token) 
			throws ClientProtocolException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.TOKEN, token);
		return hdfsHttpClientHelper
				.createHdfsURL(LITERAL.HOMEDIR, OPERATIONS.CANCELDELEGATIONTOKEN, options)
				.getHttpResultStatusCode(METHOD.PUT) == STATUS.OK;
	}
	
	private boolean setTimes(String remotePath, String modificationtime, String accesstime) 
			throws ClientProtocolException, IOException {
		Map<String, String> options = new HashMap<>();
		if(modificationtime != null)
			options.put(OPTIONS.MODIFICATIONTIME, modificationtime);
		
		if(accesstime != null)
			options.put(OPTIONS.ACCESSTIME, accesstime);
		
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.SETTIMES, options)
				.getHttpResultStatusCode(METHOD.PUT) == STATUS.OK;
	}
	
	private boolean remove(String remotePath, boolean recursive) 
			throws UnsupportedOperationException, IOException {
		Map<String, String> options = new HashMap<>();
		options.put(OPTIONS.RECURSIVE, String.valueOf(recursive));
		
		return hdfsHttpClientHelper
				.createHdfsURL(remotePath, OPERATIONS.DELETE, options)
				.getHttpResultContent(METHOD.DELETE)
				.contains(LITERAL.TRUE);
	}
	
	private int uploadFile(String op, String localPath, String remotePath, METHOD method, Map<String, String> options) 
			throws ClientProtocolException, IOException {
		File file = new File(localPath);
		if(file.isDirectory()) 
			throw new IllegalArgumentException(LITERAL.ERROR.ERROR01);

		
		// Step 1: Submit a HTTP PUT/POST request without automatically following redirects and without sending the file data.
		String redirectUrl = hdfsHttpClientHelper.createHdfsURL(remotePath, op, options)
				  								 .getHttpResultFirstHeader(method, LITERAL.LOCATION)
				  								 .getValue();
		hdfsHttpClientHelper.setCurrentURL(redirectUrl);
		
		// Step 2: Submit another HTTP PUT/POST request using the URL in the Location header with the file data to be written/appended.
		HttpEntity entity = new InputStreamEntity(new FileInputStream(file));
		return hdfsHttpClientHelper.getHttpResultStatusCode(method, entity);
	}
	
	public static void main(String[] args) {
		try {
//			Map<String, String> options = new HashMap<>();
//			options.put("overwrite", "true");
//			options.put("replication", "3");
//			options.put("buffersize", "4096");
//			options.put("permission", "755");
			
			HdfsAccess hdfsRESTfulUtil = new HdfsAccess("vm-45e5-3412", "50070", "bigdatagfts");
//			System.out.println(hdfsRESTfulUtil.upload("C:/Users/YM59750/Desktop/test.sh", "/test2.sh", null));
//			System.out.println(hdfsRESTfulUtil.append("C:/Users/YM59750/Desktop/test.sh", "/test2.sh", null));
//			System.out.println(hdfsRESTfulUtil.open("/test.sh", null));
//			System.out.println(hdfsRESTfulUtil.mkdir("/restful", null));
//			System.out.println(hdfsRESTfulUtil.rename("/tmp2.sql", "/tmp3.sql"));
//			System.out.println(hdfsRESTfulUtil.removeFile("/tmp3.sql"));
//			System.out.println(hdfsRESTfulUtil.removeDirectory("/restful"));
//			System.out.println(hdfsRESTfulUtil.getStatus("/test2.sh"));
//			System.out.println(hdfsRESTfulUtil.listDirectory("/user"));
//			System.out.println(hdfsRESTfulUtil.getDirectoryContentSummary("/"));
//			System.out.println(hdfsRESTfulUtil.getFileChecksum("/test2.sh"));
//			System.out.println(hdfsRESTfulUtil.getHomeDirectory());
//			System.out.println(hdfsRESTfulUtil.setPermission("/test2.sh", 755));
//			short replication = 4;
//			System.out.println(hdfsRESTfulUtil.setReplicationFactor("/test2.sh", replication));
//			System.out.println(hdfsRESTfulUtil.setAccessTime("/test2.sh", String.valueOf(System.currentTimeMillis())));
//			System.out.println(hdfsRESTfulUtil.setModificationTime("/tmp2.sql", String.valueOf(System.currentTimeMillis())));
			System.out.println(hdfsRESTfulUtil.getDelegationToken("bigdatagfts"));
			
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			System.out.println(e.getMessage());
		}
	}
}

package httptest;

import java.util.Map;
import java.util.Map.Entry;

import com.google.common.base.Preconditions;


public class HdfsHttpAddress extends HttpAddress {

	private static final String WEBHDFS_FLAG = "/webhdfs/v1"; 
	private String username;
	
	public HdfsHttpAddress(String host, String port, String username) {
		super(host, port);
		this.username = username;
	}
	
	public HdfsHttpAddress(String protocol, String host, String port, String username) {
		super(protocol, host, port);
		this.username = username;
	}

	public String createHdfsURL(String path, String op, Map<String, String> options) {
		Preconditions.checkArgument(path != null && !path.equals(""), "HDFS url's path can't be null/empty");
		Preconditions.checkArgument(op != null && !op.equals(""), "HDFS url's operation can't be null/empty");
		
		StringBuilder url = new StringBuilder(super.getBasicAddress() + WEBHDFS_FLAG);
		appendPath(url, path);
		appendUserName(url);
		appendOperation(url, op);
		appendOptions(url, options);
		setCurrentURL(url.toString());
		return currentURL;
	}
	
	@Override
	public String getCurrentURL() {
		return super.currentURL;
	}
	
	@Override
	public void setCurrentURL(String currentURL) {
		super.currentURL = currentURL;
	}
	
	private void appendPath(StringBuilder url, String path) {
		url.append(path).append("?");
	}
	
	private void appendUserName(StringBuilder url) {
		if (username != null) {
			url.append("user.name=").append(username).append("&");
		}
	}
	
	private void appendOperation(StringBuilder url, String op) {
		url.append("op=").append(op);
	}
	
	private void appendOptions(StringBuilder url, Map<String, String> options) {
		if(options != null) {
			for(Entry<String, String> option : options.entrySet()) {
				url.append("&")
				.append(option.getKey())
				.append("=")
				.append(option.getValue());
			}
		}
	}
}

package httptest;

import java.util.Map;

public class HdfsHttpClientHelper extends HttpClientHelper {

	public HdfsHttpClientHelper(HdfsHttpAddress hdfsHttpAddress) {
		super(hdfsHttpAddress);
	}

	public HdfsHttpClientHelper createHdfsURL(String path, String op, Map<String, String> options) {
		HdfsHttpAddress hdfsHttpAddress = (HdfsHttpAddress)httpAddress;
		hdfsHttpAddress.createHdfsURL(path, op, options);
		return this;
	}
}

package httptest;


public abstract class HttpAddress {
	final static String HTTP_DEFAULT_PROTOCOL = "http";
	protected String protocol;
	protected String host;
	protected String port;
	protected String currentURL;
	
	public HttpAddress(String protocol, String host, String port) {
		this.protocol = protocol;
		this.host = host;
		this.port = port;
	}
	
	public HttpAddress(String host, String port) {
		this(HTTP_DEFAULT_PROTOCOL, host, port);
	}
	
	public String getBasicAddress() {
		return protocol + "://" + host + ":" + port;
	}
	
	public abstract String getCurrentURL();
	
	public abstract void setCurrentURL(String currentURL);
}

package httptest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.StatusLine;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.impl.client.HttpClientBuilder;

import com.google.common.base.Preconditions;

public abstract class HttpClientHelper {
	static String HTTP_DEFAULT_PROTOCOL  = "http";

	protected HttpClient client;
	protected HttpAddress httpAddress;
	
	public HttpClientHelper(HttpAddress httpAddress) {
		client = HttpClientBuilder.create().build();
		this.httpAddress = httpAddress;
	}
	
	public static enum METHOD {
		GET, PUT, POST, DELETE
	}
	
	/**
	 * Get HTTP result's first header.
	 * @param method
	 * @param headerName
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public Header getHttpResultFirstHeader(METHOD method, String headerName, HttpEntity entity) throws ClientProtocolException, IOException {
		Preconditions.checkArgument(headerName != null && !headerName.equals(""), "Header name can't be null/empty");
		return getHttpResponse(method, entity).getFirstHeader(headerName);
	}
	
	/**
	 * Get HTTP result's first header.
	 * @param method
	 * @param headerName
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public Header getHttpResultFirstHeader(METHOD method, String headerName) throws ClientProtocolException, IOException {
		return getHttpResultFirstHeader(method, headerName, null);
	}
	
	
	/**
	 * Get HTTP result's status.
	 * @param method
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public StatusLine getHttpResultStatus(METHOD method, HttpEntity entity) throws ClientProtocolException, IOException {
		return getHttpResponse(method, entity).getStatusLine();
	}
	
	/**
	 * Get HTTP result's status.
	 * @param method
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public StatusLine getHttpResultStatus(METHOD method) throws ClientProtocolException, IOException {
		return getHttpResultStatus(method, null);
	}
	
	
	/**
	 * Get HTTP result's status code.
	 * @param method
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public int getHttpResultStatusCode(METHOD method, HttpEntity entity) throws ClientProtocolException, IOException {
		return getHttpResultStatus(method, entity).getStatusCode();
	}
	
	/**
	 * Get HTTP result's status code.
	 * @param method
	 * @return
	 * @throws ClientProtocolException
	 * @throws IOException
	 */
	public int getHttpResultStatusCode(METHOD method) throws ClientProtocolException, IOException {
		return getHttpResultStatusCode(method, null);
	}
	
	
	/**
	 * Get HTTP result's content.
	 * @param method
	 * @param entity
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public String getHttpResultContent(METHOD method, HttpEntity entity) throws UnsupportedOperationException, IOException {
		HttpResponse response = getHttpResponse(method, entity);
		InputStream contentInputStream = response.getEntity().getContent();
		BufferedReader rd = new BufferedReader(new InputStreamReader(contentInputStream));
		
		StringBuilder result = new StringBuilder();
		String line;
		while ((line = rd.readLine()) != null) {
			result.append(line);
		}
		return result.toString();
	}
	
	/**
	 * Get HTTP result's content.
	 * @param method
	 * @return
	 * @throws UnsupportedOperationException
	 * @throws IOException
	 */
	public String getHttpResultContent(METHOD method) throws UnsupportedOperationException, IOException {
		return getHttpResultContent(method, null);
	}
	
	public void setCurrentURL(String currentURL) {
		httpAddress.setCurrentURL(currentURL);
	}
	
	private HttpResponse getHttpResponse(METHOD method, HttpEntity entity) throws ClientProtocolException, IOException {
		if(method == METHOD.GET)
			return executeHttpGet();
		if(method == METHOD.PUT)
			return executeHttpPut(entity);
		if(method == METHOD.POST)
			return executeHttpPost(entity);
		if(method == METHOD.DELETE)
			return executeHttpDelete();
		throw new IllegalArgumentException();
	}
	
	private HttpResponse executeHttpGet() throws ClientProtocolException, IOException {
		HttpGet httpGet = new HttpGet(httpAddress.getCurrentURL());
		return client.execute(httpGet); 
	}
	
	private HttpResponse executeHttpPut(HttpEntity entity) throws ClientProtocolException, IOException {
		HttpPut httpPut = new HttpPut(httpAddress.getCurrentURL());
		httpPut.setEntity(entity);
		return client.execute(httpPut);
	}
	
	private HttpResponse executeHttpPost(HttpEntity entity) throws ClientProtocolException, IOException {
		HttpPost httpPost = new HttpPost(httpAddress.getCurrentURL());
		httpPost.setEntity(entity);
		return client.execute(httpPost);
	}
	
	private HttpResponse executeHttpDelete() throws ClientProtocolException, IOException {
		HttpDelete httpDelete = new HttpDelete(httpAddress.getCurrentURL());
		return client.execute(httpDelete);
	}
}




